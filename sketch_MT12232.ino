#include "font_6x8.h"

// Команды для отправки в дисплей
#define LCD_DISPLAY_ON 0xAF  //DisplayON/OFF
#define LCD_DISPLAY_OFF 0xAE
#define LCD_RESET 0xE2 //Стартовая строка ЖКИ (Display Start Line) сбрасываетсяв 0, адресс страницы устанавливается равным 0, содер-жимое ОЗУ не изменяется
#define LCD_END 0xEE //Снятие флага RMW
#define LCD_RMW 0xE0 //Read ModifyWrite
#define LCD_ADC_FORW 0xA0 //DC Select  = прямое соответствие
#define LCD_ADC_BACK 0xA1 //DC Select  = обратное соответствие
#define LCD_START_LINE 0xC0 //DisplaySTART Line
#define LCD_MULTIPLEX 0xA9 //Duty Select = 1 для МТ-12232В
#define LCD_STATIC_DRV_OFF 0xA4 //Static DriveON/OFF = обычное управление

// адреса страниц
#define PAGE0 0xB8 // Адрес страницы 0
#define PAGE1 0xB9 // Адрес страницы 1
#define PAGE2 0xBA // Адрес страницы 2
#define PAGE3 0xBB // Адрес страницы 3

byte Stripes[4][122] = 
{
  { 0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF
  },
  { 0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF
  },
  { 0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF
  },
  { 0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,
    0xFF,0xFF,0x00,0x00,0xFF,0xFF,0x00,0x00,0xFF,0xFF
  }
};

// логотип для проверки экрана
byte Logo122[4][122]=//122x32 pixel, каждые 8 вертикальных точек собраны в байт
{
	{	0xFF,0x01,0x01,0x01,0x01,0xC1,0xE1,0xB1,0x11,0x1D,0x1D,0x7F,0x7F,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFD,0xFD,0xF9,0xB1,
		0xF1,0xE1,0x81,0x01,0x01,0x01,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,
		0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xC1,0xFF
	},
	{	0xFF,0xE0,0x7C,0x7F,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0x6F,0x6F,0x07,
		0x07,0x06,0x00,0x00,0x03,0x03,0x0F,0x3F,0x07,0x07,0x07,0x03,0x03,0x07,0x0F,0x3B,
		0x13,0x80,0x80,0x23,0x9E,0xF8,0xF8,0xF8,0xFC,0xFE,0xFE,0xFE,0xFC,0x00,0x00,0x00,
		0x80,0x80,0xE0,0xF8,0xFC,0xFE,0xFE,0xFE,0xFC,0x00,0x00,0x00,0x60,0xF0,0xF8,0xF8,
		0x7C,0x3E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x1E,0x3E,0x3E,0x7E,0xFC,0xF8,0xF0,0xE0,
		0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xFE,
		0xFE,0xFE,0xFE,0xFC,0x00,0x1C,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0xFE,0xFE,0xFE,
		0xFE,0xFE,0x3E,0x3E,0x3E,0x3E,0x3E,0x3E,0x1C,0xFF
	},
	{	0xFF,0x07,0x7C,0xE0,0x80,0x00,0x1F,0x3F,0xFF,0xFF,0xFF,0xFF,0x0F,0x30,0x38,0x00,
		0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
		0xE0,0xF0,0xFC,0xFF,0xFF,0x3F,0x0F,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xF8,0xFE,0xFF,
		0x7F,0x7F,0x1F,0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		0x00,0x18,0x3C,0x7E,0x7E,0x7E,0x7E,0x7E,0x7E,0x3C,0x3C,0x18,0x00,0x00,0x01,0xFF,
		0xFF,0xFF,0xFF,0x00,0x00,0x80,0xE0,0xF0,0xFC,0xFE,0xFF,0x7F,0x1F,0x07,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF
	},
	{	0xFF,0x80,0x80,0x80,0x80,0x83,0x86,0x8C,0x98,0xB0,0xB0,0xE0,0xC0,0xC0,0x80,0x80,
		0x80,0x80,0x80,0x80,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xC0,0xE0,0xF8,0xFC,0xFF,0xFF,
		0xBF,0x8F,0x87,0x81,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x9F,0x83,0x80,
		0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x86,0x8F,0x9F,0xBF,
		0xFE,0xFC,0xF8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF8,0xF8,0xFC,0xFE,0xBF,0x9F,0x8F,
		0x87,0xE3,0xF9,0xFC,0xFF,0xFF,0xBF,0x9F,0x87,0x81,0x80,0x80,0x80,0x80,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF,0xFF,0xFF,
		0xFF,0xFF,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xFF
	}
};

// определение пинов
struct lcd_type { //Порты вывода для МЭЛТ-12232В  
  byte RES; //Сброс / Выбор типа интерфейса
  byte A0;  //Адресный сигнал—выбор между передачей данных и команд управления(А0)
  byte E;  //Разрешение обращений к модулю (а также строб данных)(1 кристалл) (А1)
  byte CS;  //Разрешение обращений к модулю (а также строб данных)(2 кристалл) (А2)
  byte RW;  //Выбор режима записи или чтения                                   (А3)
  uint8_t data_pins[8]; //порты данных
};

lcd_type LCD{
  .RES = 18,
  .A0 = 4,
  .E = 2,
  .CS = 17,
  .RW = 0,
  .data_pins = {0,1,2,3,4,5,6,7}
};

void setPins(){ // настрока пинов контроллера

 pinMode(LCD.RES, OUTPUT); // Сброс / Выбор типа интерфейса
 pinMode(LCD.A0, OUTPUT);  // Адресный сигнал—выбор между передачей данных и команд управления  
 pinMode(LCD.E, OUTPUT);  // Разрешение обращений к модулю (а также строб данных)(1 кристалл)
 pinMode(LCD.CS, OUTPUT);  // Разрешение обращений к модулю (а также строб данных)(2 кристалл)
 pinMode(LCD.RW, OUTPUT);  // Выбор режима записи или чтения

 //Порты вывода для данных D0-D7
 LCD.data_pins[0] = 13; //d0;
 LCD.data_pins[1] = 12; //d1;
 LCD.data_pins[2] = 14; //d2;
 LCD.data_pins[3] = 27; //d3; 
 LCD.data_pins[4] = 26; //d4;
 LCD.data_pins[5] = 25; //d5;
 LCD.data_pins[6] = 22; //d6;
 LCD.data_pins[7] = 23; //d7;
 
 for (int i=0; i< 8 ; ++i)
 {
   pinMode(LCD.data_pins[i], OUTPUT);
 }
}

// функция задержки
void myDelayMicroseconds(uint32_t us) {
  uint32_t tmr = micros();
  while (micros() - tmr < us);
}

// Функция чтения данных из левого кристалла
unsigned char ReadDataL() {
  unsigned char data = 0;
    // Переключаем все данные на вход
  for (int i = 0; i < 8; ++i) {
    pinMode(LCD.data_pins[i], INPUT_PULLUP);
  }
  digitalWrite(LCD.A0, HIGH); // Переводим в режим данных
  digitalWrite(LCD.RW, HIGH); // Переводим в режим чтения
  digitalWrite(LCD.CS, HIGH); // Выбираем левый кристалл
  myDelayMicroseconds(10);    // Небольшая пауза
  digitalWrite(LCD.E, LOW); // Поднимаем тактовый сигнал
  myDelayMicroseconds(1);    // Небольшая пауза
  for (int i = 0; i < 8; ++i) {
    data |= digitalRead(LCD.data_pins[i]) << i; // Читаем биты
  }
  digitalWrite(LCD.E, HIGH); // Опускаем тактовый сигнал
  myDelayMicroseconds(1);

  // Возвращаем данные в режим вывода
  for (int i = 0; i < 8; ++i) {
    pinMode(LCD.data_pins[i], OUTPUT);
  }

  return data; // Возвращаем прочитанный байт
}

// === Чтение байта из правого кристалла ===
unsigned char ReadDataR() {
  unsigned char data = 0;
  digitalWrite(LCD.A0, HIGH); // Данные
  digitalWrite(LCD.RW, HIGH); // Чтение
  digitalWrite(LCD.CS, LOW);  // Выбираем правый кристалл

  // Переключаем все данные на вход
  for (int i = 0; i < 8; ++i) {
    pinMode(LCD.data_pins[i], INPUT_PULLUP);
  }

  digitalWrite(LCD.E, LOW); // Такт
  myDelayMicroseconds(10);
  for (int i = 0; i < 8; ++i) {
    data |= digitalRead(LCD.data_pins[i]) << i;
  }
  digitalWrite(LCD.E, HIGH);
  myDelayMicroseconds(1);

  // Возврат в режим вывода
  for (int i = 0; i < 8; ++i) {
    pinMode(LCD.data_pins[i], OUTPUT);
  }

  return data;
}

// функции отправки команд и данных в кристаллы дисплея 
void WriteCode(byte b){ // передача команд в оба кристалла дисплея
  WriteByte(b,0,1);
  WriteByte(b,0,0);  
}
void WriteCodeL(byte b) // передача команд в левый кристалл
{ WriteByte(b,0,1);}

void WriteCodeR(byte b) // передача команд в правый кристалл
{ WriteByte(b,0,0);}

void WriteData(byte b) // данные в обе половины индикатора
{ WriteByte(b,1,1);
  WriteByte(b,1,0);}

void WriteDataL(byte b) 
{ WriteByte(b,1,1); }//Данные в левую половину индикатора

void WriteDataR(byte b) 
{ WriteByte(b,1,0); }//Данные в правую половину индикатора

void SendData(byte val) // программа отправки данных на дисплей
{
 for (int i = 0; i < 8; i++) {
    digitalWrite(LCD.data_pins[i], (val >> i) & 0x01);
  }  
 myDelayMicroseconds(1);  
}

void WriteByte(byte b, byte cd, byte lr) {
//При необходимости настроить здесь шину данных на вывод
  digitalWrite(LCD.RW, 0); //LCD.RW=0; 
  digitalWrite(LCD.A0, cd);  //LCD.A0=cd;  //Выдача байта в индикатор как данных или команды
  digitalWrite(LCD.CS, lr);
  SendData(b);
  myDelayMicroseconds(1);
  //Delay(>40ns); //Это время предустановки адреса (tAW) реализовано в отправке
  digitalWrite(LCD.E, 1);  //LCD.E1=l; 
  myDelayMicroseconds(1);    //Delay(>160ns);    //Длительность сигналов E1,E2=1 (время предустановки данных попало сюда (tDS))
  digitalWrite(LCD.E, 0); //LCD.E1 = LCD.E2 =0;  //Сбросить сигналы E1 и E2 
  myDelayMicroseconds(3);    //Delay(>(2000ns-40ns-160ns));  //Минимально допустимый интервал между сигналами E1,E2=1
}

// настройка дисплея
void LCD_Init(){ // настройка дисплея
  digitalWrite(LCD.E, HIGH);  //LCD.E=0;//Начальное значение сигнала индикатору
  digitalWrite(LCD.RES,LOW);  //LCD.RES=0;//Выдать сигнал RES=0 индикатору
  myDelayMicroseconds(15);    // Delay(>10us);//Задержка на время больше 10 мкс
  digitalWrite(LCD.RES,HIGH); //LCD.RES=1;//Снять сигнал RES
  delay(5);                   //Delay(>1ms);//Задержка на время больше 1 мс
  WriteCode(LCD_RESET);       //Reset //LCD_RESET
  WriteCode(LCD_END);         //ReadModifyWrite off //LCD_END
  WriteCode(LCD_STATIC_DRV_OFF);//Включить обычный режим //LCD_STATIC_DRV_OFF
  WriteCode(LCD_MULTIPLEX);     //Мультиплекс 1/32 //LCD_MULTIPLEX
  WriteCode(LCD_DISPLAY_ON);    //Display on //LCD_DISPLAY_ON
  WriteCode(LCD_START_LINE);    //Верхнюю строку на 0 //LCD_START_LINE
  WriteCodeR(LCD_ADC_FORW);      //NonInvert scan RAM //LCD_ADC_FORW
  WriteCodeL(LCD_ADC_BACK);      //NonInvert scan RAM //LCD_ADC_FORW
}

void setup() {  // настройка работы дисплея и контроллера
 setPins();
 LCD_Init();
}

void loop() {
  byte  p; //Номер текущей страницы индикатора
  byte  c; //Позиция по горизонтали выводимого байта
LCD_Clear(0, 122);
delay(1000);
LCD_Pixel(5,11,1);
LCD_Pixel(6,12,1);
LCD_Pixel(7,13,1);
delay(2000);
LCD_Line(10,16,80,25,1);
delay(2000);

 /* for(p=0; p<4; p++) {//Цикл по всем 4-м страницам индикатора
    WriteCodeL(p|0xB8);//Установка текущей страницы для обоих кристаллов индикатора
    WriteCodeL(0x13);
    for(c=0; c<61; c++) {//Цикл вывода данных в левую половину индикатора
      WriteDataL(Logo122[p][c]);//Вывод очередного байта в индикатор
      //WriteDataL(Stripes[p][c]);//Вывод очередного байта в индикатор
    }
    WriteCodeR(p|0xB8);//Установка текущей страницы для обоих кристаллов индикатора
    WriteCodeR(0x00);
    for(c=61; c<122; c++) {//Цикл вывода данных в правую половину индикатора
      WriteDataR(Logo122[p][c]);//Вывод очередного байта в индикатор
      //WriteDataR(Stripes[p][c]);//Вывод очередного байта в индикатор
    }
  }*/
}

// РАБОТА С ИЗОБРАЖЕНИЯМИ И ТЕКСТОМ
// функция очистки дисплея
void LCD_Clear (unsigned char x1, unsigned char x2){
for (unsigned char p = 0; p < 4; p++) {
    WriteCodeL(PAGE0 + p);  // Установка текущей страницы
    WriteCodeR(PAGE0 + p);
    
    // Левая половина
    digitalWrite(LCD.CS, 1);
    for (unsigned char c = x1; c < 61; c++) {
      WriteCodeL(c + 19);  // Установка адреса колонки
      WriteDataL(0x00);
    }
    
    // Правая половина
    digitalWrite(LCD.CS, 0);
    for (unsigned char c = 61; c < x2; c++) {
      WriteCodeR(c - 61);  // Установка адреса колонки
      WriteDataR(0x00);
    }
  }
}

// рисование пикселя
void LCD_Pixel(unsigned char xPos, unsigned char yPos, unsigned char action) {
  unsigned char currentData;
  if (xPos >= 122 || yPos >= 32) return; // Защита от выхода за границы

  byte page = PAGE0 + (yPos / 8);       // Вычисляем номер страницы
  byte bitMask = 1 << (yPos % 8);       // Битовая маска для нужного пикселя

  if (xPos < 61) {
    digitalWrite(LCD.CS, HIGH); // Левый кристалл
    WriteCodeL(page);           // Переход на страницу
    WriteCodeL(xPos + 19);      // Установка X-адреса

    ReadDataL(); // Чтение текущего байта
    currentData = ReadDataL(); // Чтение текущего байта

    if (action == 1){
      currentData |= bitMask;
      }  // Включаем пиксель
    else{
      currentData &= ~bitMask;             // Выключаем пиксель
    }

    WriteCodeL(xPos + 19);      // Установка X-адреса
    WriteDataL(currentData); // Запись изменённого байта
  } else {
    byte x = xPos - 61;
    digitalWrite(LCD.CS, LOW); // Правый кристалл
    WriteCodeR(page);          // Переход на страницу
    WriteCodeR(x);             // Установка X-адреса

    ReadDataR(); // Чтение текущего байта
    currentData = ReadDataR(); // Чтение текущего байта

    if (action == 1){
      currentData |= bitMask;
    }
    else{
      currentData &= ~bitMask;
    }

    WriteCodeR(x);             // Установка X-адреса
    WriteDataR(currentData);
  }
}

// рисование линии
void LCD_Line(int x0, int y0, int x1, int y1, unsigned char met) {
  int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
  int dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
  int err = (dx > dy ? dx : -dy) / 2, e2;
  for (;;) {
    LCD_Pixel(x0, y0, met);
    if (x0 == x1 && y0 == y1) break;
    e2 = err;
    if (e2 > -dx) { err -= dy; x0 += sx; }
    if (e2 < dy) { err += dx; y0 += sy; }
  }
}

// === Рисование прямоугольника ===
void LCD_DrawRect(int x, int y, int width, int height, unsigned char mode) {
  LCD_Line(x, y, x + width - 1, y, mode);                // Верхняя сторона
  LCD_Line(x, y, x, y + height - 1, mode);               // Левая сторона
  LCD_Line(x + width - 1, y, x + width - 1, y + height - 1, mode); // Правая сторона
  LCD_Line(x, y + height - 1, x + width - 1, y + height - 1, mode); // Нижняя сторона
}

// === Заливка прямоугольника ===
void LCD_FillRect(int x, int y, int width, int height, unsigned char mode) {
  for (int i = 0; i < height; i++) {
    LCD_Line(x, y + i, x + width - 1, y + i, mode);
  }
}

// === Рисование окружности по алгоритму Брезенхэма ===
void LCD_DrawCircle(int x0, int y0, int radius, unsigned char mode) {
  int f = 1 - radius;
  int ddF_x = 1;
  int ddF_y = -2 * radius;
  int x = 0;
  int y = radius;

  LCD_Pixel(x0, y0 + radius, mode);
  LCD_Pixel(x0, y0 - radius, mode);
  LCD_Pixel(x0 + radius, y0, mode);
  LCD_Pixel(x0 - radius, y0, mode);

  while (x < y) {
    if (f >= 0) {
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x;

    LCD_Pixel(x0 + x, y0 + y, mode);
    LCD_Pixel(x0 - x, y0 + y, mode);
    LCD_Pixel(x0 + x, y0 - y, mode);
    LCD_Pixel(x0 - x, y0 - y, mode);
    LCD_Pixel(x0 + y, y0 + x, mode);
    LCD_Pixel(x0 - y, y0 + x, mode);
    LCD_Pixel(x0 + y, y0 - x, mode);
    LCD_Pixel(x0 - y, y0 - x, mode);
  }
}

// === Рисование треугольника через три линии ===
void LCD_DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, unsigned char mode) {
  LCD_Line(x1, y1, x2, y2, mode);
  LCD_Line(x2, y2, x3, y3, mode);
  LCD_Line(x3, y3, x1, y1, mode);
}

// === Вывод одного символа ===
void LCD_DrawChar(int x, int y, char ch) {
  // Шрифт font_6x8 имеет символы с ASCII 32 (' ') по 127 (DEL)
  if (ch < 32 || ch > 127) return; // Пропустить неподдерживаемые символы

  const byte *glyph = font_6x8_Data + (ch - 32) * 6; // Получаем адрес символа в шрифте

  for (int col = 0; col < 6; col++) {
    byte bits = pgm_read_byte(glyph + col);
    for (int row = 0; row < 8; row++) {
      if (bits & (1 << row)) {
        LCD_Pixel(x + col, y + row, 1);
      }
    }
  }
}

// === Вывод строки текста ===
void LCD_Print(int x, int y, const char *text) {
  while (*text) {
    LCD_DrawChar(x, y, *text++);
    x += 6; // Сдвигаемся на ширину символа
  }
}